package model.commands;

// Model package imports
import model.interfaces.IShapeCommand;
import model.interfaces.IUndoable;
import model.shape.Shape;
import model.trackers.CommandLists;
import model.trackers.CommandHistory;
import model.shape.ShapeType;

// Java lib imports
import java.util.ArrayList;
import java.awt.Point;
import java.util.List;

public class MoveCommand implements IShapeCommand, IUndoable {

    public Point mousePressed;
    public Point mouseReleased;
    public ShapeType shapeType;
    public CommandLists commandLists;
    public List<Shape> movedShapesList = new ArrayList<>();
    public int deltaX;
    public int deltaY;

    public MoveCommand(Point mousePressed, Point mouseReleased, ShapeType shapeType, CommandLists commandLists){

        this.commandLists = commandLists;
        this.shapeType = shapeType;
        this.mousePressed = mousePressed;
        this.mouseReleased = mouseReleased;

        deltaX = (mouseReleased.x - mousePressed.x);
        deltaY = (mouseReleased.y - mousePressed.y);
    }

    @Override
    public void run() {

        // Move the selected shape or shapes
        move(commandLists.selectedShapesList);

        // Repaint the canvas
        commandLists.drawShapeList.drawShape.paintCanvas.repaint();

        // Render the shape in its new location
        render(movedShapesList);
        commandLists.drawShapeList.drawShape.draw(commandLists.drawShapeList.masterShapeList);

        // Add to command history
        CommandHistory.add(this);
    }

    private void move(List<model.shape.Shape> selectedShapesList) {

        // For every shape in the selection, move it by offset generated by click-and-drag action
        for(Shape shape: selectedShapesList) {

            // Set new target coordinates for the clicked shape
            int newStartPointX = (shape.startPoint.x) + deltaX;
            int newStartPointY = (shape.startPoint.y) + deltaY;
            int newEndPointX = (shape.endPoint.x) + deltaX;
            int newEndPointY = (shape.endPoint.y) + deltaY;

            // Attributes for shape at new coordinates
            Point newStartPoint = new Point(newStartPointX, newStartPointY);
            Point newEndPoint = new Point(newEndPointX, newEndPointY);

            Shape movedShape = new Shape(shape.shapeType, newStartPoint, newEndPoint, shape.primaryColor, shape.secondaryColor, shape.shadingType);

            // Add moved shape to trackers
            movedShapesList.add(shape);
            movedShapesList.add(movedShape);

            System.out.println("Shape " + shape + " has been moved!");

        }

        // Clear list of selected shapes since operation is complete
        selectedShapesList.clear();

    }

    private void render(List<Shape> movedShapesList) {
        for (Shape shape : movedShapesList) {

            // If the master list doesn't have the moved shape, then add it
            if (!commandLists.drawShapeList.masterShapeList.contains(shape)) {
                commandLists.drawShapeList.masterShapeList.add(shape);
            }

            // Remove the original shape from the master list
            else {
                commandLists.drawShapeList.masterShapeList.remove(shape);
            }
        }
    }

    @Override
    public void undo() {

        if (movedShapesList.size() == 0){
            System.out.println("-----------------------------------------");
            System.out.println("Nothing was moved to undo!");
            System.out.println("-----------------------------------------");
        }

        else {
            // If the master list has the moved shape, remove it.
            for (Shape shape : movedShapesList) {

                // This works because every odd index object is a moved shape.
                if (movedShapesList.indexOf(shape) % 2 == 0) {
                    commandLists.drawShapeList.masterShapeList.add(shape);
                }

                else {
                    commandLists.drawShapeList.masterShapeList.remove(shape);
                }
            }
            commandLists.drawShapeList.drawShape.paintCanvas.repaint();
            commandLists.drawShapeList.drawShape.draw(commandLists.drawShapeList.masterShapeList);

            System.out.println();
            System.out.println("-----------------------------------------");
            System.out.println("Undid move operation!");
            System.out.println("-----------------------------------------");
            System.out.println();
        }
    }

    @Override
    public void redo() {
        if (movedShapesList.size() == 0){
            System.out.println("-----------------------------------------");
            System.out.println("Nothing to redo!");
            System.out.println("-----------------------------------------");
        }

        // If the master list has the original shape, remove it.
        else {
            for (Shape shape : movedShapesList) {

                // This works because every odd index object is a moved shape.
                if (movedShapesList.indexOf(shape) % 2 != 0) {
                    commandLists.drawShapeList.masterShapeList.add(shape);
                }

                else {
                    commandLists.drawShapeList.masterShapeList.remove(shape);
                }
            }

            // Redraw canvas
            commandLists.drawShapeList.drawShape.paintCanvas.repaint();
            commandLists.drawShapeList.drawShape.draw(commandLists.drawShapeList.masterShapeList);

            System.out.println();
            System.out.println("-----------------------------------------");
            System.out.println("Redid move operation!");
            System.out.println("-----------------------------------------");
            System.out.println();
        }

    }
}